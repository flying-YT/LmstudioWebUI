<!DOCTYPE html>
<html>
<head>
<title>LM Studio Chat with Office File Upload</title>
<style>

body {
  font-family: sans-serif;
  margin: 0;
  height: 100vh;
  overflow: hidden;
  display: flex;
  flex-direction: column;
}

h1 {
  text-align: center;
  margin: 10px 0;
}

#chat-container {
  border: 1px solid #ccc;
  padding: 10px;
  overflow-y: scroll;
  margin: 0 auto;
  width: 90%;
  flex-grow: 1; /* 高さを柔軟に調整 */
}

.message-wrapper {
  display: flex;
  margin-bottom: 10px;
  width: 100%;
}

.user-message-wrapper {
  justify-content: flex-end;
}

.bot-message-wrapper {
  justify-content: flex-start;
}

.message {
  padding: 8px 12px;
  border-radius: 10px;
  word-break: break-word;
  max-width: 80%;
  display: inline-block;
}

.user-message {
  background-color: #DCF8C6;
}

.bot-message {
  background-color: #ECE5DD;
}

#controls-area {
  width: 90%;
  margin: 0 auto;
  padding: 10px 0;
}

#file-preview-container {
  display: flex;
  gap: 10px;
  margin-bottom: 10px;
  overflow-x: auto;
  padding: 5px 0;
}

.preview-item {
  position: relative;
  flex-shrink: 0;
}

.preview-item img, .preview-item .text-preview {
  max-height: 80px;
  border-radius: 5px;
  border: 1px solid #ddd;
}

.preview-item .text-preview {
    font-size: 12px;
    padding: 5px;
    background-color: #f0f0f0;
    white-space: pre-wrap;
    overflow-y: hidden;
    max-width: 150px;
}


.remove-file-btn {
  position: absolute;
  top: -5px;
  right: -5px;
  background-color: rgba(0, 0, 0, 0.7);
  color: white;
  border: none;
  border-radius: 50%;
  width: 20px;
  height: 20px;
  cursor: pointer;
  font-weight: bold;
  line-height: 18px;
  text-align: center;
}

#prompt-area {
  display: flex;
  align-items: flex-end; /* 要素の高さを下端で揃える */
  gap: 10px;
}

#prompt-input {
  flex-grow: 1;
  padding: 8px;
  border: 1px solid #ccc;
  border-radius: 5px;
  resize: vertical;
  min-height: 40px; /* 最小高さを設定 */
  max-height: 200px; /* 最大高さを設定 */
  overflow-y: auto;
}

#button-container {
    display: flex;
    flex-direction: column;
    gap: 5px;
}

#file-input-label {
    padding: 8px 12px;
    background-color: #f0f0f0;
    border: 1px solid #ccc;
    border-radius: 5px;
    cursor: pointer;
    text-align: center;
}

#send-button {
  padding: 8px 15px;
  border-radius: 5px;
  border: none;
  background-color: #007bff;
  color: white;
  cursor: pointer;
}

#clear-button {
  margin-top: 10px;
  padding: 8px;
  width: 100%;
}

/* Markdown styles */
.markdown p {
  margin: 0.5em 0;
}
.markdown pre {
  background-color: #f0f0f0;
  padding: 10px;
  border-radius: 5px;
  overflow-x: auto;
}
.markdown code {
  font-family: monospace;
}
.markdown img {
    max-width: 100%;
    height: auto;
}

/* 設定モーダルのスタイルを修正 */
#settings-modal {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: white;
  padding: 20px;
  border: 1px solid #ccc;
  border-radius: 10px;
  z-index: 1000;
  box-shadow: 0 4px 8px rgba(0,0,0,0.1);
  display: none; /* 初期状態では非表示 */
}
#settings-modal h2 {
    margin-top: 0;
}
#settings-modal label {
    display: block;
    margin-bottom: 5px;
}
#settings-modal input {
    width: 100%;
    padding: 8px;
    margin-bottom: 10px;
    box-sizing: border-box;
}
/* モーダル内ボタンのスタイルを追加 */
#settings-modal-buttons {
    text-align: right;
}
#settings-modal button {
    margin-left: 5px;
}
</style>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/markdown-it/13.0.1/markdown-it.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.7.0/mammoth.browser.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

<meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

  <h1>LM Studio Chat</h1>

  <div id="chat-container"></div>

  <div id="controls-area">
    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
      <button id="settings-button">Settings</button>
      <span id="current-server-display" style="font-size: 0.9em; color: #555;">Server not set</span>
    </div>

    <div id="settings-modal">
      <h2>Server Settings</h2>
      <label for="ip-input">IP Address:</label>
      <input type="text" id="ip-input" placeholder="e.g., localhost">
      <label for="port-input">Port:</label>
      <input type="text" id="port-input" placeholder="e.g., 1234">
      <div id="settings-modal-buttons">
        <button id="save-settings-button">Save</button>
        <button id="cancel-settings-button">Cancel</button>
      </div>
    </div>

    <div id="file-preview-container"></div>
    <div id="prompt-area">
      <textarea id="prompt-input" placeholder="Enter your prompt"></textarea>
      <div id="button-container">
        <label id="file-input-label" for="file-input">file</label>
        <input type="file" id="file-input" multiple style="display: none;" accept=".txt,.md,.js,.py,.html,.css,.json,.csv,.docx,.xlsx,image/*">
        <button id="send-button">Send</button>
      </div>
    </div>
    <button id="clear-button">Clear History</button>
  </div>

<script>
  // --- Global Variables and Initial Setup ---
  // --- グローバル変数と初期設定 ---

  // DOM Elements
  // DOM要素の取得
  const chatContainer = document.getElementById('chat-container');
  const promptInput = document.getElementById('prompt-input');
  const sendButton = document.getElementById('send-button');
  const clearButton = document.getElementById('clear-button');
  const fileInput = document.getElementById('file-input');
  const filePreviewContainer = document.getElementById('file-preview-container');
  // Get DOM elements for the settings UI.
  // 設定UIのDOM要素を取得
  const settingsButton = document.getElementById('settings-button');
  const settingsModal = document.getElementById('settings-modal');
  const ipInput = document.getElementById('ip-input');
  const portInput = document.getElementById('port-input');
  const saveSettingsButton = document.getElementById('save-settings-button');
  const cancelSettingsButton = document.getElementById('cancel-settings-button');
  const currentServerDisplay = document.getElementById('current-server-display');

  // Initialize markdown-it with highlight.js for code syntax highlighting.
  // highlight.js を使ってコードのシンタックスハイライトを有効にした markdown-it を初期化します。
  const md = new markdownit({
    highlight: function (str, lang) {
      if (lang && hljs.getLanguage(lang)) {
        try {
          // Return highlighted HTML.
          // ハイライトされたHTMLを返す。
          return '<pre class="hljs"><code>' +
            hljs.highlight(str, { language: lang, ignoreIllegals: true }).value +
            '</code></pre>';
        } catch (__) {}
      }
      // Return escaped HTML if language is not supported or an error occurs.
      // 言語がサポートされていない、またはエラーが発生した場合は、エスケープされたHTMLを返す。
      return '<pre class="hljs"><code>' + md.utils.escapeHtml(str) + '</code></pre>';
    }
  });

  // State variables
  // 状態を管理する変数
  let conversationHistory = [];
  let attachedFiles = [];
  // Add variables to store server settings.
  // サーバー設定を格納する変数を追加
  let serverIp = '';
  let serverPort = '';


  // --- Settings Modal Logic ---
  // --- 設定モーダルのロジック ---

  // Event listener for the settings button click.
  // 設定ボタンクリック時のイベントリスナー。
  settingsButton.addEventListener('click', () => {
    // Display the current values in the input fields.
    // 現在の値を入力欄に表示
    ipInput.value = serverIp;
    portInput.value = serverPort;
    settingsModal.style.display = 'block';
  });

  // Event listener for the save settings button click.
  // 設定保存ボタンクリック時のイベントリスナー。
  saveSettingsButton.addEventListener('click', () => {
    // Get the input values and store them in variables.
    // 入力値を取得して変数に格納
    serverIp = ipInput.value.trim();
    serverPort = portInput.value.trim();
    if (serverIp && serverPort) {
      // Close the modal.
      // モーダルを閉じる
      settingsModal.style.display = 'none'; 
      // Update the display.
      // 表示を更新
      updateServerDisplay(); 
      alert(`Server set to: http://${serverIp}:${serverPort}`);
    } else {
      alert('Please enter both IP address and port.');
    }
  });
  
  // Add an event listener for the cancel button.
  // キャンセルボタンのイベントリスナーを追加
  cancelSettingsButton.addEventListener('click', () => {
    // Just close the modal.
    // モーダルを閉じるだけ
    settingsModal.style.display = 'none'; 
  });
  
  // Add a function to update the server display.
  // サーバー表示を更新する関数を追加
  function updateServerDisplay() {
      if (serverIp && serverPort) {
        currentServerDisplay.textContent = `Server: http://${serverIp}:${serverPort}`;
      } else {
        currentServerDisplay.textContent = 'Server not set';
      }
  }


  // --- ★★★ Advanced File Selection Processing ★★★ ---
  // --- ★★★ ファイル選択処理の高度化 ★★★ ---

  // Event listener for file selection.
  // ファイル選択時のイベントリスナー。
  fileInput.addEventListener('change', async (event) => {
    // Loop through each selected file.
    // 選択された各ファイルをループ処理する。
    for (const file of event.target.files) {
      try {
        // Process each selected file.
        // 選択された各ファイルを処理します。
        const fileData = await processFile(file);
        if (fileData) {
          attachedFiles.push(fileData);
        }
      } catch (error) {
        console.error("Error processing file:", file.name, error);
        // It's also good to add a UI to notify the user of the error.
        // エラーをユーザーに通知するUIを追加しても良い
      }
    }
    // Update the file preview area.
    // ファイルプレビューエリアを更新します。
    displayFilePreview();
    // Clear the file input value to allow selecting the same file again.
    // 同じファイルを再度選択できるように、ファイル入力の値をクリアします。
    fileInput.value = ''; // Clear the value to allow selecting the same file again.
  });

  // Processes a file based on its type.
  // ファイルをその種類に応じて処理する非同期関数。
  // A function to process files based on their type.
  // ファイルを種類に応じて処理する関数
  async function processFile(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      const extension = file.name.split('.').pop().toLowerCase();

      reader.onload = async (e) => {
        try {
          let content;
          const fileType = file.type;
          
          if (extension === 'docx') {
            const result = await mammoth.extractRawText({ arrayBuffer: e.target.result });
            content = result.value;
          } else if (extension === 'xlsx') {
            const data = new Uint8Array(e.target.result);
            // Check if the file is a binary ZIP (typical for XLSX).
            // ファイルがバイナリZIP形式（通常のXLSX）か確認する。
            if (data.length > 2 && data[0] === 0x50 && data[1] === 0x4B) {
                try {
                    const workbook = XLSX.read(e.target.result, { type: 'array' });
                    let fullText = '';
                    workbook.SheetNames.forEach(sheetName => {
                        const worksheet = workbook.Sheets[sheetName];
                        const sheetText = XLSX.utils.sheet_to_csv(worksheet);
                        fullText += `--- Sheet: ${sheetName} ---\n${sheetText}\n\n`;
                    });
                    content = fullText.trim();
                } catch (err) {
                    console.error("Error parsing binary XLSX file:", err);
                    content = "Error: Failed to parse XLSX file.";
                }
            } else {
                // Try decoding as text (e.g., CSV saved with .xlsx extension).
                // テキストとしてのデコードを試みる（例：.xlsx拡張子で保存されたCSV）。
                try {
                   const decoder = new TextDecoder('utf-16le', { fatal: true });
                   content = decoder.decode(data);
                } catch (error) {
                   const decoder = new TextDecoder('utf-8');
                   content = decoder.decode(data);
                }
            }
          } else if (fileType.startsWith('image/')) {
            content = e.target.result; // Base64
          } else if (fileType.startsWith('text/') || isTextBasedExtension(extension)) {
            content = e.target.result; // Plain text
          } else {
             console.warn(`Unsupported file type: ${file.name}. Reading as text.`);
             // Attempt to read as text if unknown.
             // 不明な場合はテキストとして試みる
             content = e.target.result; 
          }
          
          resolve({
            name: file.name,
            // Use extension if MIME type is not available.
            // MIMEタイプがなければ拡張子
            type: fileType || extension, 
            content: content
          });

        } catch (err) {
          reject(err);
        }
      };

      reader.onerror = (err) => reject(err);

      // Read file based on its type.
      // ファイルの種類に応じて読み込む。
      if (extension === 'docx' || extension === 'xlsx') {
        reader.readAsArrayBuffer(file);
      } else if (file.type.startsWith('image/')) {
        reader.readAsDataURL(file);
      } else {
        reader.readAsText(file);
      }
    });
  }
  
  // Helper function to check if a file extension is text-based.
  // ファイル拡張子がテキストベースかどうかを判定するヘルパー関数。
  function isTextBasedExtension(ext) {
    return ['txt', 'md', 'js', 'py', 'html', 'css', 'json', 'csv'].includes(ext);
  }

  // --- Display File Preview ---
  // --- ファイルプレビュー表示---
  function displayFilePreview() {
    filePreviewContainer.innerHTML = '';
    attachedFiles.forEach((file, index) => {
      const previewItem = document.createElement('div');
      previewItem.classList.add('preview-item');

      // Check if the file is an image.
      // ファイルが画像かチェックする。
      if (file.type.startsWith('image/')) {
        const img = document.createElement('img');
        img.src = file.content;
        previewItem.appendChild(img);
      } else {
        const textPreview = document.createElement('div');
        textPreview.classList.add('text-preview');
        // Show the first 100 characters of the text content.
        // テキスト内容の最初の100文字を表示する。
        textPreview.textContent = String(file.content).substring(0, 100) + '...';
        const fileName = document.createElement('p');
        fileName.textContent = file.name;
        fileName.style.margin = '0';
        fileName.style.fontWeight = 'bold';
        previewItem.append(fileName, textPreview);
      }
      
      const removeBtn = document.createElement('button');
      removeBtn.classList.add('remove-file-btn');
      removeBtn.innerHTML = '&times;';
      // Set the action to remove the file when the button is clicked.
      // ボタンがクリックされたときにファイルを削除するアクションを設定。
      removeBtn.onclick = () => {
        attachedFiles.splice(index, 1);
        displayFilePreview();
      };

      previewItem.appendChild(removeBtn);
      filePreviewContainer.appendChild(previewItem);
    });
  }

  // --- Clear Conversation ---
  // --- 会話クリア ---
  function clearConversation() {
    conversationHistory = [];
    attachedFiles = [];
    chatContainer.innerHTML = '';
    displayFilePreview();
  }
  // Event listener for the clear conversation button.
  // 会話クリアボタンのイベントリスナー。
  clearButton.addEventListener('click', clearConversation);

  // --- Send Message ---
  // --- メッセージ送信 ---
  sendButton.addEventListener('click', async () => {
    // Check if the server settings are configured.
    // サーバー設定がされているかチェック
    if (!serverIp || !serverPort) {
      alert('Please set the server IP address and port in Settings first.');
      // Abort the process if not configured.
      // 設定されていなければ処理を中断
      return; 
    }

    const prompt = promptInput.value.trim();
    // If there is no prompt and no files attached, do nothing.
    // プロンプトがなく、ファイルも添付されていない場合は何もしない。
    if (!prompt && attachedFiles.length === 0) return;

    // Clear the input field.
    // 入力フィールドをクリアする。
    promptInput.value = '';

    // Prepare arrays for API request and display content.
    // APIリクエスト用と表示用のコンテンツを準備する。
    const userMessageContent = [];
    let displayHTML = '';

    // If there is a text prompt, add it.
    // テキストプロンプトがあれば追加する。
    if (prompt) {
      userMessageContent.push({ type: 'text', text: prompt });
      displayHTML += `<p>${prompt.replace(/\n/g, '<br>')}</p>`;
    }

    // Process each attached file.
    // 添付された各ファイルを処理する。
    attachedFiles.forEach(file => {
      // If the file is an image.
      // ファイルが画像の場合。
      if (file.type.startsWith('image/')) {
        userMessageContent.push({
          type: 'image_url',
          image_url: { url: file.content }
        });
        displayHTML += `<img src="${file.content}" style="max-height: 150px; border-radius: 5px; margin-top: 5px;">`;
      } else {
        // If the file is text-based.
        // ファイルがテキストベースの場合。
        const fileContentText = `\n\n--- File: ${file.name} ---\n${file.content}`;
        const lastTextContent = userMessageContent.find(c => c.type === 'text');
        // If there is already text content, append to it.
        // 既にテキストコンテンツがあれば追記する。
        if(lastTextContent){
            lastTextContent.text += fileContentText;
        } else {
            // Otherwise, add a new text content entry.
            // なければ新しいテキストコンテンツとして追加する。
            userMessageContent.push({ type: 'text', text: fileContentText });
        }
        displayHTML += `<div style="background-color: #eee; padding: 5px; border-radius: 5px; margin-top: 5px; font-size: 0.9em;"><p><b>${file.name}</b></p><pre style="white-space: pre-wrap; max-height: 100px; overflow-y: auto;">${file.content}</pre></div>`;
      }
    });

    // Create and display the user's message bubble.
    // ユーザーのメッセージ吹き出しを生成して表示する。
    const userMessageWrapper = document.createElement('div');
    userMessageWrapper.classList.add('message-wrapper', 'user-message-wrapper');
    const userMessageDiv = document.createElement('div');
    userMessageDiv.classList.add('message', 'user-message');
    userMessageDiv.innerHTML = displayHTML;
    userMessageWrapper.appendChild(userMessageDiv);
    chatContainer.appendChild(userMessageWrapper);
    // Scroll to the bottom of the chat.
    // チャットの最下部にスクロールする。
    chatContainer.scrollTop = chatContainer.scrollHeight;

    // Create a history entry for the user's message.
    // ユーザーメッセージの履歴エントリを作成する。
    const historyEntry = { role: "user" };
    historyEntry.content = userMessageContent.length === 1 && userMessageContent[0].type === 'text'
      ? userMessageContent[0].text
      : userMessageContent;
    conversationHistory.push(historyEntry);

    // Clear attached files and update the preview area.
    // 添付ファイルをクリアし、プレビューエリアを更新する。
    attachedFiles = [];
    displayFilePreview();
    // Keep only the last 7 entries in the conversation history.
    // 会話履歴を最後の7件に制限する。
    conversationHistory = conversationHistory.slice(-7);

    // Create a placeholder for the bot's response.
    // ボットの応答用のプレースホルダーを作成する。
    const botMessageWrapper = document.createElement('div');
    botMessageWrapper.classList.add('message-wrapper', 'bot-message-wrapper');
    const botMessageDiv = document.createElement('div');
    botMessageDiv.classList.add('message', 'bot-message', 'markdown');
    botMessageWrapper.appendChild(botMessageDiv);
    chatContainer.appendChild(botMessageWrapper);

    // Define responseText outside to be accessible in the finally block.
    // finallyブロックでも使えるように外で定義
    let responseText = ''; 

    try {
      // Dynamically generate the API URL based on the settings.
      // 設定されたIPとポートを元に動的にURLを生成
      const apiUrl = `http://${serverIp}:${serverPort}/v1/chat/completions`;

      // Send the request to the API.
      // APIにリクエストを送信する。
      const response = await fetch(apiUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          messages: conversationHistory,
          stream: true
        }),
      });

      // Throw an error if the HTTP response is not OK.
      // HTTPレスポンスがOKでない場合はエラーをスローする。
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      
      // Get the reader and decoder for the streaming response.
      // ストリーミングレスポンスのためのリーダーとデコーダーを取得する。
      const reader = response.body.getReader();
      const decoder = new TextDecoder("utf-8");
      let buffer = '';

      // Loop to read the stream.
      // ストリームを読み取るループ。
      while (true) {
        const { done, value } = await reader.read();
        if (done) {
          // Let the finally block handle adding history when the stream is complete.
          // ストリーム完了時の履歴追加はfinallyに任せる
          break;
        }
        buffer += decoder.decode(value, {stream: true});
        const lines = buffer.split('\n');
        buffer = lines.pop();
        for (const line of lines) {
            // Check for server-sent event data lines.
            // サーバーセントイベントのデータ行かチェックする。
            if (line.startsWith('data: ')) {
                const jsonString = line.substring(6);
                if (jsonString === '[DONE]') {
                    // The stream completion process is handled in the finally block outside the while loop.
                    // ストリーム完了処理はwhileループの外、finallyブロックで行う
                    return; 
                }
                try {
                    const json = JSON.parse(jsonString);
                    const content = json.choices[0].delta?.content || "";
                    if (content) {
                        // Append the new content and re-render the bot's message.
                        // 新しいコンテンツを追記し、ボットのメッセージを再描画する。
                        responseText += content;
                        botMessageDiv.innerHTML = md.render(responseText);
                        chatContainer.scrollTop = chatContainer.scrollHeight;
                    }
                } catch (error) {
                    console.error("Could not parse JSON:", jsonString, error);
                }
            }
        }
      }
    } catch (error) {
      responseText = `An error occurred: ${error.message}`;
      // Display the error message.
      // エラーメッセージを表示
      botMessageDiv.innerHTML = responseText; 
      console.error("Fetch error:", error);
    } finally {
        // Ensure rendering and history addition are performed.
        // レンダリングと履歴追加を確実に行う
        botMessageDiv.innerHTML = md.render(responseText);
        chatContainer.scrollTop = chatContainer.scrollHeight;
        hljs.highlightAll();
        // Add to history only if the last message does not have the same content.
        // 最後のメッセージが同じ内容でない場合のみ履歴に追加
        if (conversationHistory.length === 0 || conversationHistory[conversationHistory.length - 1]?.content !== responseText) {
             if(responseText.trim()){
                 conversationHistory.push({role: "assistant", content: responseText});
             }
        }
    }
  });

  // --- Key Input Event (No changes) ---
  // --- キー入力イベント (変更なし) ---
  promptInput.addEventListener('keydown', (e) => {
      // If Enter is pressed without Shift,
      // ShiftキーなしでEnterキーが押された場合、
      if (e.key === 'Enter' && !e.shiftKey) {
          // prevent the default action (new line) and click the send button.
          // デフォルトの動作（改行）を防ぎ、送信ボタンをクリックする。
          e.preventDefault();
          sendButton.click();
      }
  });
</script>

</body>
</html>