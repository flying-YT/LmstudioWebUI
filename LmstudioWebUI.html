<!DOCTYPE html>
<html>
<head>
<title>LM Studio Chat with Office File Upload</title>
<style>
/* CSSスタイルは前回のものから変更ありません */
body {
  font-family: sans-serif;
  margin: 0;
  height: 100vh;
  overflow: hidden;
  display: flex;
  flex-direction: column;
}

h1 {
  text-align: center;
  margin: 10px 0;
}

#chat-container {
  border: 1px solid #ccc;
  padding: 10px;
  overflow-y: scroll;
  margin: 0 auto;
  width: 90%;
  flex-grow: 1; /* 高さを柔軟に調整 */
}

.message-wrapper {
  display: flex;
  margin-bottom: 10px;
  width: 100%;
}

.user-message-wrapper {
  justify-content: flex-end;
}

.bot-message-wrapper {
  justify-content: flex-start;
}

.message {
  padding: 8px 12px;
  border-radius: 10px;
  word-break: break-word;
  max-width: 80%;
  display: inline-block;
}

.user-message {
  background-color: #DCF8C6;
}

.bot-message {
  background-color: #ECE5DD;
}

#controls-area {
  width: 90%;
  margin: 0 auto;
  padding: 10px 0;
}

#file-preview-container {
  display: flex;
  gap: 10px;
  margin-bottom: 10px;
  overflow-x: auto;
  padding: 5px 0;
}

.preview-item {
  position: relative;
  flex-shrink: 0;
}

.preview-item img, .preview-item .text-preview {
  max-height: 80px;
  border-radius: 5px;
  border: 1px solid #ddd;
}

.preview-item .text-preview {
    font-size: 12px;
    padding: 5px;
    background-color: #f0f0f0;
    white-space: pre-wrap;
    overflow-y: hidden;
    max-width: 150px;
}


.remove-file-btn {
  position: absolute;
  top: -5px;
  right: -5px;
  background-color: rgba(0, 0, 0, 0.7);
  color: white;
  border: none;
  border-radius: 50%;
  width: 20px;
  height: 20px;
  cursor: pointer;
  font-weight: bold;
  line-height: 18px;
  text-align: center;
}

#prompt-area {
  display: flex;
  align-items: flex-end; /* 要素の高さを下端で揃える */
  gap: 10px;
}

#prompt-input {
  flex-grow: 1;
  padding: 8px;
  border: 1px solid #ccc;
  border-radius: 5px;
  resize: vertical;
  min-height: 40px; /* 最小高さを設定 */
  max-height: 200px; /* 最大高さを設定 */
  overflow-y: auto;
}

#button-container {
    display: flex;
    flex-direction: column;
    gap: 5px;
}

#file-input-label {
    padding: 8px 12px;
    background-color: #f0f0f0;
    border: 1px solid #ccc;
    border-radius: 5px;
    cursor: pointer;
    text-align: center;
}

#send-button {
  padding: 8px 15px;
  border-radius: 5px;
  border: none;
  background-color: #007bff;
  color: white;
  cursor: pointer;
}

#clear-button {
  margin-top: 10px;
  padding: 8px;
  width: 100%;
}

/* Markdown styles */
.markdown p {
  margin: 0.5em 0;
}
.markdown pre {
  background-color: #f0f0f0;
  padding: 10px;
  border-radius: 5px;
  overflow-x: auto;
}
.markdown code {
  font-family: monospace;
}
.markdown img {
    max-width: 100%;
    height: auto;
}

/* 設定モーダルのスタイルを修正 */
#settings-modal {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: white;
  padding: 20px;
  border: 1px solid #ccc;
  border-radius: 10px;
  z-index: 1000;
  box-shadow: 0 4px 8px rgba(0,0,0,0.1);
  display: none; /* 初期状態では非表示 */
}
#settings-modal h2 {
    margin-top: 0;
}
#settings-modal label {
    display: block;
    margin-bottom: 5px;
}
#settings-modal input {
    width: 100%;
    padding: 8px;
    margin-bottom: 10px;
    box-sizing: border-box;
}
/* モーダル内ボタンのスタイルを追加 */
#settings-modal-buttons {
    text-align: right;
}
#settings-modal button {
    margin-left: 5px;
}
</style>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/markdown-it/13.0.1/markdown-it.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.7.0/mammoth.browser.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

<meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

  <h1>LM Studio Chat</h1>

  <div id="chat-container"></div>

  <div id="controls-area">
    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
      <button id="settings-button">Settings</button>
      <span id="current-server-display" style="font-size: 0.9em; color: #555;">Server not set</span>
    </div>

    <div id="settings-modal">
      <h2>Server Settings</h2>
      <label for="ip-input">IP Address:</label>
      <input type="text" id="ip-input" placeholder="e.g., localhost">
      <label for="port-input">Port:</label>
      <input type="text" id="port-input" placeholder="e.g., 1234">
      <div id="settings-modal-buttons">
        <button id="save-settings-button">Save</button>
        <button id="cancel-settings-button">Cancel</button>
      </div>
    </div>

    <div id="file-preview-container"></div>
    <div id="prompt-area">
      <textarea id="prompt-input" placeholder="Enter your prompt"></textarea>
      <div id="button-container">
        <label id="file-input-label" for="file-input">file</label>
        <input type="file" id="file-input" multiple style="display: none;" accept=".txt,.md,.js,.py,.html,.css,.json,.csv,.docx,.xlsx,image/*">
        <button id="send-button">Send</button>
      </div>
    </div>
    <button id="clear-button">Clear History</button>
  </div>

<script>
  // --- Global Variables and Initial Setup ---
  // --- グローバル変数と初期設定 ---

  // DOM Elements
  // DOM要素の取得
  const chatContainer = document.getElementById('chat-container');
  const promptInput = document.getElementById('prompt-input');
  const sendButton = document.getElementById('send-button');
  const clearButton = document.getElementById('clear-button');
  const fileInput = document.getElementById('file-input');
  const filePreviewContainer = document.getElementById('file-preview-container');
  // 設定UIのDOM要素を取得
  const settingsButton = document.getElementById('settings-button');
  const settingsModal = document.getElementById('settings-modal');
  const ipInput = document.getElementById('ip-input');
  const portInput = document.getElementById('port-input');
  const saveSettingsButton = document.getElementById('save-settings-button');
  const cancelSettingsButton = document.getElementById('cancel-settings-button');
  const currentServerDisplay = document.getElementById('current-server-display');

  // Initialize markdown-it with highlight.js for code syntax highlighting.
  // highlight.js を使ってコードのシンタックスハイライトを有効にした markdown-it を初期化します。
  const md = new markdownit({
    highlight: function (str, lang) {
      if (lang && hljs.getLanguage(lang)) {
        try {
          // Return highlighted HTML.
          // ハイライトされたHTMLを返す。
          return '<pre class="hljs"><code>' +
            hljs.highlight(str, { language: lang, ignoreIllegals: true }).value +
            '</code></pre>';
        } catch (__) {}
      }
      // Return escaped HTML if language is not supported or an error occurs.
      // 言語がサポートされていない、またはエラーが発生した場合は、エスケープされたHTMLを返す。
      return '<pre class="hljs"><code>' + md.utils.escapeHtml(str) + '</code></pre>';
    }
  });

  // State variables
  // 状態を管理する変数
  let conversationHistory = [];
  let attachedFiles = [];
  // サーバー設定を格納する変数を追加
  let serverIp = '';
  let serverPort = '';


  // --- Settings Modal Logic ---
  // --- 設定モーダルのロジック ---
  settingsButton.addEventListener('click', () => {
    // 現在の値を入力欄に表示
    ipInput.value = serverIp;
    portInput.value = serverPort;
    settingsModal.style.display = 'block';
  });

  saveSettingsButton.addEventListener('click', () => {
    // 入力値を取得して変数に格納
    serverIp = ipInput.value.trim();
    serverPort = portInput.value.trim();
    if (serverIp && serverPort) {
      settingsModal.style.display = 'none'; // モーダルを閉じる
      updateServerDisplay(); // 表示を更新
      alert(`Server set to: http://${serverIp}:${serverPort}`);
    } else {
      alert('Please enter both IP address and port.');
    }
  });
  
  // キャンセルボタンのイベントリスナーを追加
  cancelSettingsButton.addEventListener('click', () => {
    settingsModal.style.display = 'none'; // モーダルを閉じるだけ
  });
  
  // サーバー表示を更新する関数を追加
  function updateServerDisplay() {
      if (serverIp && serverPort) {
        currentServerDisplay.textContent = `Server: http://${serverIp}:${serverPort}`;
      } else {
        currentServerDisplay.textContent = 'Server not set';
      }
  }


  // --- ★★★ ファイル選択処理の高度化 ★★★ ---
  fileInput.addEventListener('change', async (event) => {
    for (const file of event.target.files) {
      try {
        // Process each selected file.
        // 選択された各ファイルを処理します。
        const fileData = await processFile(file);
        if (fileData) {
          attachedFiles.push(fileData);
        }
      } catch (error) {
        console.error("Error processing file:", file.name, error);
        // エラーをユーザーに通知するUIを追加しても良い
      }
    }
    // Update the file preview area.
    // ファイルプレビューエリアを更新します。
    displayFilePreview();
    // Clear the file input value to allow selecting the same file again.
    // 同じファイルを再度選択できるように、ファイル入力の値をクリアします。
    fileInput.value = ''; // 同じファイルを再度選択できるように値をクリア
  });

  // Processes a file based on its type.
  // ファイルをその種類に応じて処理する非同期関数。
  // ファイルを種類に応じて処理する関数
  async function processFile(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      const extension = file.name.split('.').pop().toLowerCase();

      reader.onload = async (e) => {
        try {
          let content;
          const fileType = file.type;
          
          if (extension === 'docx') {
            const result = await mammoth.extractRawText({ arrayBuffer: e.target.result });
            content = result.value;
          } else if (extension === 'xlsx') {
            const data = new Uint8Array(e.target.result);
            if (data.length > 2 && data[0] === 0x50 && data[1] === 0x4B) {
                try {
                    const workbook = XLSX.read(e.target.result, { type: 'array' });
                    let fullText = '';
                    workbook.SheetNames.forEach(sheetName => {
                        const worksheet = workbook.Sheets[sheetName];
                        const sheetText = XLSX.utils.sheet_to_csv(worksheet);
                        fullText += `--- Sheet: ${sheetName} ---\n${sheetText}\n\n`;
                    });
                    content = fullText.trim();
                } catch (err) {
                    console.error("Error parsing binary XLSX file:", err);
                    content = "Error: Failed to parse XLSX file.";
                }
            } else {
                try {
                   const decoder = new TextDecoder('utf-16le', { fatal: true });
                   content = decoder.decode(data);
                } catch (error) {
                   const decoder = new TextDecoder('utf-8');
                   content = decoder.decode(data);
                }
            }
          } else if (fileType.startsWith('image/')) {
            content = e.target.result; // Base64
          } else if (fileType.startsWith('text/') || isTextBasedExtension(extension)) {
            content = e.target.result; // Plain text
          } else {
             console.warn(`Unsupported file type: ${file.name}. Reading as text.`);
             content = e.target.result; // 不明な場合はテキストとして試みる
          }
          
          resolve({
            name: file.name,
            type: fileType || extension, // MIMEタイプがなければ拡張子
            content: content
          });

        } catch (err) {
          reject(err);
        }
      };

      reader.onerror = (err) => reject(err);

      if (extension === 'docx' || extension === 'xlsx') {
        reader.readAsArrayBuffer(file);
      } else if (file.type.startsWith('image/')) {
        reader.readAsDataURL(file);
      } else {
        reader.readAsText(file);
      }
    });
  }
  
  function isTextBasedExtension(ext) {
    return ['txt', 'md', 'js', 'py', 'html', 'css', 'json', 'csv'].includes(ext);
  }

  // --- ファイルプレビュー表示---
  function displayFilePreview() {
    filePreviewContainer.innerHTML = '';
    attachedFiles.forEach((file, index) => {
      const previewItem = document.createElement('div');
      previewItem.classList.add('preview-item');

      if (file.type.startsWith('image/')) {
        const img = document.createElement('img');
        img.src = file.content;
        previewItem.appendChild(img);
      } else {
        const textPreview = document.createElement('div');
        textPreview.classList.add('text-preview');
        textPreview.textContent = String(file.content).substring(0, 100) + '...';
        const fileName = document.createElement('p');
        fileName.textContent = file.name;
        fileName.style.margin = '0';
        fileName.style.fontWeight = 'bold';
        previewItem.append(fileName, textPreview);
      }
      
      const removeBtn = document.createElement('button');
      removeBtn.classList.add('remove-file-btn');
      removeBtn.innerHTML = '&times;';
      removeBtn.onclick = () => {
        attachedFiles.splice(index, 1);
        displayFilePreview();
      };

      previewItem.appendChild(removeBtn);
      filePreviewContainer.appendChild(previewItem);
    });
  }

  // --- 会話クリア ---
  function clearConversation() {
    conversationHistory = [];
    attachedFiles = [];
    chatContainer.innerHTML = '';
    displayFilePreview();
  }
  clearButton.addEventListener('click', clearConversation);

  // --- メッセージ送信 ---
  sendButton.addEventListener('click', async () => {
    // サーバー設定がされているかチェック
    if (!serverIp || !serverPort) {
      alert('Please set the server IP address and port in Settings first.');
      return; // 設定されていなければ処理を中断
    }

    const prompt = promptInput.value.trim();
    if (!prompt && attachedFiles.length === 0) return;

    promptInput.value = '';

    const userMessageContent = [];
    let displayHTML = '';

    if (prompt) {
      userMessageContent.push({ type: 'text', text: prompt });
      displayHTML += `<p>${prompt.replace(/\n/g, '<br>')}</p>`;
    }

    attachedFiles.forEach(file => {
      if (file.type.startsWith('image/')) {
        userMessageContent.push({
          type: 'image_url',
          image_url: { url: file.content }
        });
        displayHTML += `<img src="${file.content}" style="max-height: 150px; border-radius: 5px; margin-top: 5px;">`;
      } else {
        const fileContentText = `\n\n--- File: ${file.name} ---\n${file.content}`;
        const lastTextContent = userMessageContent.find(c => c.type === 'text');
        if(lastTextContent){
            lastTextContent.text += fileContentText;
        } else {
            userMessageContent.push({ type: 'text', text: fileContentText });
        }
        displayHTML += `<div style="background-color: #eee; padding: 5px; border-radius: 5px; margin-top: 5px; font-size: 0.9em;"><p><b>${file.name}</b></p><pre style="white-space: pre-wrap; max-height: 100px; overflow-y: auto;">${file.content}</pre></div>`;
      }
    });

    const userMessageWrapper = document.createElement('div');
    userMessageWrapper.classList.add('message-wrapper', 'user-message-wrapper');
    const userMessageDiv = document.createElement('div');
    userMessageDiv.classList.add('message', 'user-message');
    userMessageDiv.innerHTML = displayHTML;
    userMessageWrapper.appendChild(userMessageDiv);
    chatContainer.appendChild(userMessageWrapper);
    chatContainer.scrollTop = chatContainer.scrollHeight;

    const historyEntry = { role: "user" };
    historyEntry.content = userMessageContent.length === 1 && userMessageContent[0].type === 'text'
      ? userMessageContent[0].text
      : userMessageContent;
    conversationHistory.push(historyEntry);

    attachedFiles = [];
    displayFilePreview();
    conversationHistory = conversationHistory.slice(-7);

    const botMessageWrapper = document.createElement('div');
    botMessageWrapper.classList.add('message-wrapper', 'bot-message-wrapper');
    const botMessageDiv = document.createElement('div');
    botMessageDiv.classList.add('message', 'bot-message', 'markdown');
    botMessageWrapper.appendChild(botMessageDiv);
    chatContainer.appendChild(botMessageWrapper);

    let responseText = ''; // finallyブロックでも使えるように外で定義

    try {
      // 設定されたIPとポートを元に動的にURLを生成
      const apiUrl = `http://${serverIp}:${serverPort}/v1/chat/completions`;

      const response = await fetch(apiUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          messages: conversationHistory,
          stream: true
        }),
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      
      const reader = response.body.getReader();
      const decoder = new TextDecoder("utf-8");
      let buffer = '';

      while (true) {
        const { done, value } = await reader.read();
        if (done) {
          // ストリーム完了時の履歴追加はfinallyに任せる
          break;
        }
        buffer += decoder.decode(value, {stream: true});
        const lines = buffer.split('\n');
        buffer = lines.pop();
        for (const line of lines) {
            if (line.startsWith('data: ')) {
                const jsonString = line.substring(6);
                if (jsonString === '[DONE]') {
                    // ストリーム完了処理はwhileループの外、finallyブロックで行う
                    return; 
                }
                try {
                    const json = JSON.parse(jsonString);
                    const content = json.choices[0].delta?.content || "";
                    if (content) {
                        responseText += content;
                        botMessageDiv.innerHTML = md.render(responseText);
                        chatContainer.scrollTop = chatContainer.scrollHeight;
                    }
                } catch (error) {
                    console.error("Could not parse JSON:", jsonString, error);
                }
            }
        }
      }
    } catch (error) {
      responseText = `An error occurred: ${error.message}`;
      botMessageDiv.innerHTML = responseText; // エラーメッセージを表示
      console.error("Fetch error:", error);
    } finally {
        // レンダリングと履歴追加を確実に行う
        botMessageDiv.innerHTML = md.render(responseText);
        chatContainer.scrollTop = chatContainer.scrollHeight;
        hljs.highlightAll();
        // 最後のメッセージが同じ内容でない場合のみ履歴に追加
        if (conversationHistory.length === 0 || conversationHistory[conversationHistory.length - 1]?.content !== responseText) {
             if(responseText.trim()){
                 conversationHistory.push({role: "assistant", content: responseText});
             }
        }
    }
  });

  // --- キー入力イベント (変更なし) ---
  promptInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          sendButton.click();
      }
  });
</script>

</body>
</html>